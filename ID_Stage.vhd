-- File name: ID_Stage.vhdl
-- File Description: instruction decoded DA, DB, and Immediate value will be fetched
-- All control signals are generated 
-- control signals are generated based on instruction for EX, ME, and wB stage 
-- Control signal are generated by ID stgae 
-- RegDst,ALUSrc, Jump, Branch,ALU(2), ALU(1),ALU(0),   for EX stage
-- MemRead, MemWrite for MEM stage
--MemToReg and RegWrite for WB stage 

library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.numeric_std.all;

entity ID_Stage is
  Port (clk:in std_logic;
		instruction_in: in std_logic_vector(31 downto 0);  --- 32 bit instruction 
        DA_Value,DB_Value,Imm_Value:out std_logic_vector(31 downto 0); -- all values DA, DB and Immdiate value for calc
		RegWrite:in std_logic;                    -- check Regwrite in WB stage
		Branch_stall: in STD_LOGIC;    --- stall pipeline 
		Write_Back: in std_logic_vector(4 downto 0);  -- write back regiter in WB stage 
		WriteB_Value:in std_logic_vector(31 downto 0); --- write back value in wb stage 
		--  Control signal is combined of all stages control signal 
		-- Control signal(10 downto 4) are ex stage signal RegDst& ALUSrc & Jump & Branch & ALU 
		-- control signal (3 downto 2) are for MEM stage (MemRead & MemWrite likewise) and (1 downto 0) for WB stage (MemToReg & RegWrite)
		Control_signal: out std_logic_vector (10 downto 0)
       );
end ID_Stage;

architecture rtl of ID_Stage is

-- predefine Opcodecode for all operations

constant R_TYPE : std_logic_vector(5 downto 0) := "000000";  -- R type Instruction here SUBU, SRL, XOR 
constant NORI_Opcode : std_logic_vector(5 downto 0) := "000001"; -- Nor Immdiate opration
constant NANDI_Opcode : std_logic_vector(5 downto 0) := "000100"; -- NAND immdiate Oprarion
constant ADDI_Opcode : std_logic_vector(5 downto 0) := "000110"; -- ADD immdiate Oprarion
constant BEQ_Opcode : std_logic_vector(5 downto 0) := "000111";  -- Branch if equal 
constant LH_Opcode : std_logic_vector(5 downto 0) := "001000";  -- Load half word 
constant SW_Opcode : std_logic_vector(5 downto 0) := "001001"; --store word 
constant JR_Opcode : std_logic_vector(5 downto 0) := "001010"; -- Jump on value of DA register 
constant J_Opcode : std_logic_vector(5 downto 0) := "001011";  -- Jump on immdiate address value
signal Gen_Control: STD_LOGIC_VECTOR(10 downto 0); 
constant SUBU_FN : std_logic_vector(5 downto 0) := "000101"; -- unsigned Subtraction R type
constant SRL_FN : std_logic_vector(5 downto 0) := "000010";  -- Shift right logical  R type
constant XOR_FN : std_logic_vector(5 downto 0) := "000011"; -- XOR opration R type

type reg_array is array (0 to 31) of std_logic_vector(31 downto 0);  -- define register bank with 32 registers each one is 32 bit 
signal reg_bank : reg_array := (others => (others =>'0'));

begin 

	process(WriteB_Value,RegWrite)
    begin
		if(Write_Back/="00000" and RegWrite='1') then
            reg_bank(to_integer(unsigned(Write_Back)))<=WriteB_Value;   
        end if;    
    end process;
	
	process(Branch_stall,instruction_in(5 downto 0),instruction_in(31 downto 26)) begin
    if(Branch_stall='1') then  -- branch taken then control signals should be disabled
        Gen_Control <= (others=>'X'); -- so the generated all control signals should be unknown 
    else 
        case instruction_in(31 downto 26) is
            when R_type=>  
              case instruction_in(5 downto 0) is
                when SRL_FN => 
				 Gen_Control <= "10000100001"; -- RegDst= 1, ALU =010 , Regwrite = 1
                when SUBU_FN => 
				 Gen_Control <= "10001010001"; -- RegDst = 1, ALU =101 , Regwrite = 1
                when XOR_FN => 
				 Gen_Control <= "10000110001"; -- RegDst = 1, ALU =110 , Regwrite = 1
                when others => 
				 null;
                end case;  
            when NORI_Opcode =>
				Gen_Control <="01000010001"; -- ALUSrc = 1, ALU =001 , Regwrite = 1
			when NANDI_Opcode =>
				Gen_Control <="01001000001"; -- ALUSrc = 1, ALU =100 , Regwrite = 1
			when ADDI_Opcode =>
				Gen_Control <="01001100001"; -- ALUSrc = 1, ALU =110 , Regwrite = 1
			when BEQ_Opcode =>
				Gen_Control <="00011110010"; -- Branch = 1, ALU = 111
			when LH_Opcode =>
				Gen_Control <="01000001011"; -- ALUSrc = 1, ALU =000 , Regwrite = 1, MemToReg= 1, MemRead=1
			when SW_Opcode=>
				Gen_Control<="01000000110";  -- ALUSrc = 1, ALU =000 , MemToReg= 1, MemWrite=1
			when JR_Opcode=>
				Gen_Control<="0011XXX0000";  -- JUMP = 1, Branch =1 
			when J_Opcode=>
				Gen_Control<="0010XXX0000"; -- Jump =1 
            when others =>   
				Gen_Control <="XXXXXXXXXXX"; 
        end case;
    end if;
	end process;
	Control_signal<= Gen_Control;
process(clk, instruction_in)
	begin
	 if falling_edge(clk) then
		DA_Value <= reg_bank(to_integer(unsigned(instruction_in(25 downto 21))));   ---input 1 read
		DB_Value <= reg_bank(to_integer(unsigned(instruction_in(20 downto 16))));   --- input 2 
		if instruction_in(31 downto 26)= J_Opcode then
			Imm_Value<= ((31 downto 26 => Instruction_in(25))& Instruction_in(25 downto 0));
		else
			Imm_Value<= ((31 downto 16 => Instruction_in(15)) & Instruction_in(15 downto 0));
		end if;
	end if;
end process;
end rtl;
